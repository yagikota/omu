#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>

int main(void) {
    double d0, d1, d2, d3, d4, d5, d6, d7, d8;
    int N;
    double c;
    double *a;

    // 代入(=), 加算(+), 大小比較(<)とする。

    // 問1
    // 8段のソフトウェアパイプライン処理を用いる場合のプログラムは下記のプログラムと同じである。

    // (=)が8個
    d0 = 0.0; d1 = 0.0; d2 = 0.0; d3 = 0.0;
    d4 = 0.0; d5 = 0.0; d6 = 0.0; d7 = 0.0;

    // (=)が1個
    int i = 0;

    // (=)が9([(N-1)/8] + 1)個, ただし[]はガウス記号
    //(+)が9([(N-1)/8] + 1)個
    //(<)が([(N-1)/8] + 2)個
    while (i < N) {
        d0 = d0 + a[i + 0];
        d1 = d1 + a[i + 1];
        d2 = d2 + a[i + 2];
        d3 = d3 + a[i + 3];
        d4 = d4 + a[i + 4];
        d5 = d5 + a[i + 5];
        d6 = d6 + a[i + 6];
        d7 = d7 + a[i + 7];
        i = i + 8;
    }

    // (=)が1個, (+)が7個
    c = d0 + d1 + d2 + d3 + d4 + d5 + d6 + d7;

    // 以上より、
    //(=): 8 + 1 + 9([(N-1) / 8] + 1) + 1 = 9[(N-1)/8] + 19
    //(+): 9([(N-1)/8] + 1) + 7 = 9[(N-1)/8] + 16
    //(<): [(N-1)/8] + 2
    //合計: 19[(N-1)/8] + 37


    // 問2
    // 4段のソフトウェアパイプライン処理を用いる場合のプログラムは下記のプログラムと同じである。

    // (=)が4個
    d0 = 0.0; d1 = 0.0; d2 = 0.0; d3 = 0.0;

    // (=)が1個
    int i = 0;

    // (=)が5([(N-1)/4] + 1)個, ただし[]はガウス記号
    //(+)が5([(N-1)/4] + 1)個
    //(<)が([(N-1)/4] + 2)個
    while (i < N) {
        d0 = d0 + a[i + 0];
        d1 = d1 + a[i + 1];
        d2 = d2 + a[i + 2];
        d3 = d3 + a[i + 3];
        i = i + 4;
    }

    // (=)が1個, (+)が3個
    c = d0 + d1 + d2 + d3;

    // 以上より、
    //(=): 4 + 1 + 5([(N-1)/4] + 1) + 1 = 5[(N-1)/4] + 11
    //(+): 5([(N-1)/4] + 1) + 3 = 5[(N-1)/4] + 8
    //(<): [(N-1)/4] + 2
    //合計: 11[(N-1)/4] + 21


    // 問3
    // 2段のソフトウェアパイプライン処理を用いる場合のプログラムは下記のプログラムと同じである。

    // (=)が2個
    d0 = 0.0; d1 = 0.0;

    // (=)が1個
    int i = 0;

    // (=)が3([(N-1)/2] + 1)個, ただし[]はガウス記号
    //(+)が3([(N-1)/2] + 1)個
    //(<)が([(N-1)/2] + 2)個
    while (i < N) {
        d0 = d0 + a[i + 0];
        d1 = d1 + a[i + 1];
        i = i + 4;
    }

    // (=)が1個, (+)が1個
    c = d0 + d1;

    // 以上より、
    //(=): 2 + 1 + 3([(N-1)/2] + 1) + 1 = 3[(N-1)/4] + 7
    //(+): 3([(N-1)/2] + 1) + 1 = 3[(N-1)/2] + 4
    //(<): [(N-1)/2] + 2
    //合計: 7[(N-1)/2] + 13


    // 問4
    // N = 1億の場合、基本演算の数は、表1のようになる。

    // 表1 ソフトウェアパイプライン処理と基本演算の数の関係
    //--------------------------------------------------------------------------------
    // ソフトウェアパイプライン処理   なし          2段         4段         8段
    // 基本演算の数(N=1億)[×10^6]     500           350         275         238
    //--------------------------------------------------------------------------------

    // 8段のパイプライン処理を行なった場合が一番、基本演算の数が少ないので、この場合が
    // 最も、データハザードによるロスを減らして性能をあげられていると考えられるが、
    // 実行時間は、表2のようになる。

    // 表2 ソフトウェアパイプライン処理と実行時間の関係
    //--------------------------------------------------------------------------------
    // ソフトウェアパイプライン処理   なし          2段         4段         8段
    // 実行時間（秒）                 0.105992      0.064217    0.046516    0.047850
    //--------------------------------------------------------------------------------

    //よって、実際には、4段のパイプライン処理を行なった場合が一番、データハザードによる
    // ロスを減らして性能をあげられていると考えられる。このことから、基本演算の数が少ない
    // からと言って、実行時間が短くなるわけではないということがわかる。また、どれだけの系列
    // で分割すれば最も性能をあげられるかはプロセッサに依存するということもわかる。
}